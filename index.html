<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Z32 GPS Experiment</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
  <style>
    body { font-family: system-ui, -apple-system, Roboto, 'Segoe UI', Arial; margin: 16px; }
    .container { display:flex; gap:20px; align-items:flex-start; }
    .grid-wrap { display:flex; flex-direction:column; align-items:flex-start; min-width:400px; }
    .grid { display:grid; grid-template-columns: repeat(17, 36px); grid-template-rows: repeat(2, 48px); gap:2px; }
    .cell { width:36px; height:48px; display:flex; justify-content:center; align-items:center; font-weight:700; font-size:18px; }
    .cell.bordered { border:2px solid #333; border-radius:6px; }
    .cell.empty { background:transparent; }
    .controls { margin-top:12px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; min-width:400px; }
    button { padding:8px 12px; border-radius:8px; border:1px solid #888; background:#f6f6f6; cursor:pointer }
    button:active { transform:translateY(1px) }
    .stats { margin-top:8px; width:120px; flex-shrink:0; white-space: nowrap;}
    .hits-box { width:420px; max-height:560px; overflow:auto; border:1px solid #ddd; padding:8px; border-radius:8px; margin-top:12px; }
    .hit-item { padding:6px 4px; border-bottom:1px dashed #eee; }
    .digits { font-family: monospace; letter-spacing:2px; }
    .highlight { background:yellow; padding:2px 0; border-radius:3px; }
    .map-modal { position:fixed; inset:0; background: rgba(0,0,0,0.4); display:flex; align-items:center; justify-content:center; }
    .map-container { width:90vw; height:80vh; background:white; border-radius:10px; overflow:hidden; position:relative; }
    .close-map { position:absolute; right:8px; top:8px; z-index:1000; }
    #map { width:100%; height:100%; }
  </style>
</head>
<body>
  <h2>Z32 GPS Experiment</h2>
  <div class="container">
    <div class="grid-wrap">
      <div id="grid" class="grid" aria-hidden="true"></div>

      <div class="controls">
        <button id="simulateBtn">Simulate</button>
        <button id="pauseBtn">Pause</button>
        <button id="mapsBtn">Maps</button>
        <label><input type="checkbox" id="includeReversals" checked> Include Reversals</label>
        <label><input type="checkbox" id="adjacentOnly"> Only Adjacent Substrings</label>
        <div class="stats">
          <div>Trials: <span id="trials">0</span></div>
          <div>Hits: <span id="hits">0</span></div>
          <div>Hit rate: <span id="rate">0%</span></div>
        </div>

      </div>
        <h3>Last 25 Hits</h3>
        <div id="hitsBox" class="hits-box"></div>
	  
    </div>
  </div>

  <div id="mapModal" class="map-modal" style="display:none">
    <div class="map-container">
      <button class="close-map" id="closeMap">Close</button>
      <div id="map"></div>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script>
    const ROWS = 2, COLS = 17;
    const TOTAL_CELLS = ROWS * COLS;
    const ACTIVE_DIGITS = 32;
    const RECT = { latMax:46.1457, latMin:43.7446, lonMax:-58.1194, lonMin:-60.6995 };  // geomagnetic
    const dLat = 78.59; const dLong = 289.82; // 1970 declination

    let trials = 0, hits = 0, running = false, intervalId = null;
    let last25 = [];

    const gridEl = document.getElementById('grid');
    const cells = [];
    for (let i=0;i<TOTAL_CELLS;i++){
      const div = document.createElement('div');
      div.className = 'cell';
      if (i<ACTIVE_DIGITS) div.classList.add('bordered'); else div.classList.add('empty');
      gridEl.appendChild(div);
      cells.push(div);
    }

    const trialsEl = document.getElementById('trials');
    const hitsEl = document.getElementById('hits');
    const rateEl = document.getElementById('rate');
    const hitsBox = document.getElementById('hitsBox');
    const includeReversalsCheckbox = document.getElementById('includeReversals');
    const adjacentOnlyCheckbox = document.getElementById('adjacentOnly');

    function randDigits32(){ let s=''; for(let i=0;i<ACTIVE_DIGITS;i++) s+=Math.floor(Math.random()*10); return s; }
    function formatFrom5digits(s){ return parseFloat(s.slice(0,2)+'.'+s.slice(2)); }

    function checkHit(d32){
      const starts=[];
      for(let i=0;i<=ACTIVE_DIGITS-5;i++) starts.push(i);
      const adjOnly=adjacentOnlyCheckbox.checked;
      const includeRev=includeReversalsCheckbox.checked;

      for(let a=0;a<starts.length;a++){
        for(let b=a+1;b<starts.length;b++){
          if(adjOnly && b !== a+5) continue;
          const s1=d32.slice(starts[a], starts[a]+5);
          const s2=d32.slice(starts[b], starts[b]+5);
          const variants1=includeRev?[s1,s1.split('').reverse().join('')]:[s1];
          const variants2=includeRev?[s2,s2.split('').reverse().join('')]:[s2];

          for(let v1 of variants1){
            for(let v2 of variants2){
              const lat=formatFrom5digits(v1);
              const lon=-formatFrom5digits(v2);
              if(lat<=RECT.latMax && lat>=RECT.latMin && lon<=RECT.lonMax && lon>=RECT.lonMin){
                return {hit:true, match:{startA:starts[a], startB:starts[b], v1,v2, lat, lon}};
              }
            }
          }
        }
      }
      return {hit:false};
    }

    function updateGrid(digits){ for(let i=0;i<ACTIVE_DIGITS;i++) cells[i].textContent=digits[i]; for(let i=ACTIVE_DIGITS;i<TOTAL_CELLS;i++) cells[i].textContent=''; }

    function addHitRecord(d32, match){
      const record={digits:d32, match, time:new Date()};
      last25.unshift(record); if(last25.length>25) last25.pop();
      renderHitsBox(); if(map) renderMarkers();
    }

    function renderHitsBox(){
      hitsBox.innerHTML='';
      last25.forEach((rec,idx)=>{
        const div=document.createElement('div'); div.className='hit-item';
        const digitsSpan=document.createElement('div'); digitsSpan.className='digits';
        for(let i=0;i<rec.digits.length;i++){
          const ch=document.createElement('span'); ch.textContent=rec.digits[i];
          const a=rec.match.startA,b=rec.match.startB;
          if(i>=a && i<a+5) ch.classList.add('highlight');
          if(i>=b && i<b+5) ch.classList.add('highlight');
          digitsSpan.appendChild(ch);
        }
        const info=document.createElement('div'); info.style.fontSize='12px';
        info.textContent=`Lat: ${rec.match.lat.toFixed(3)}  Lon: ${rec.match.lon.toFixed(3)}`;
        div.appendChild(digitsSpan); div.appendChild(info); hitsBox.appendChild(div);
      });
    }

    function updateStats(){ trialsEl.textContent=trials; hitsEl.textContent=hits; rateEl.textContent=trials?((hits/trials*100).toFixed(3)+'%'):'0%'; }

    function iteration(){ const d32=randDigits32(); updateGrid(d32); const res=checkHit(d32); trials++; if(res.hit){hits++; addHitRecord(d32,res.match);} updateStats(); }

    const simulateBtn=document.getElementById('simulateBtn');
    const pauseBtn=document.getElementById('pauseBtn');
    const mapsBtn=document.getElementById('mapsBtn');

    function startSimulation(){ trials=0; hits=0; last25=[]; updateStats(); renderHitsBox(); if(intervalId) clearInterval(intervalId); running=true; intervalId=setInterval(iteration,1); }
    function pauseSimulation(){ if(intervalId) clearInterval(intervalId); intervalId=null; running=false; }

    simulateBtn.addEventListener('click',()=>startSimulation());
    pauseBtn.addEventListener('click',()=>{if(running) pauseSimulation(); else {if(!intervalId) intervalId=setInterval(iteration,1); running=true;}});

    let map, markersLayer;
    const mapModal=document.getElementById('mapModal');
    const closeMap=document.getElementById('closeMap');

    function openMap(){
      mapModal.style.display='flex';
      setTimeout(()=>{
        if(!map){
          map=L.map('map').setView([44.95,-59.4],8);
          L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19, attribution:'&copy; OpenStreetMap contributors'}).addTo(map);
          markersLayer=L.layerGroup().addTo(map);
        }
        renderMarkers(); map.invalidateSize();
      },50);
    }

    function closeMapModal(){ mapModal.style.display='none'; }
    closeMap.addEventListener('click',closeMapModal);
    mapModal.addEventListener('click', e=>{ if(e.target===mapModal) closeMapModal(); });
    mapsBtn.addEventListener('click',()=>{openMap();});

    function renderMarkers(){
      if(!markersLayer) return;
      markersLayer.clearLayers();
      last25.forEach((rec, idx)=>{
        const converted = convertFromMag([rec.match.lat, rec.match.lon], dLat, dLong);
        console.log(converted);
        // const marker=L.marker([rec.match.lat, rec.match.lon]);
        const marker=L.marker(converted);
        marker.bindPopup(`<b>#${idx+1}</b><br>${rec.digits}<br>Lat: ${rec.match.lat.toFixed(3)} Lon: ${rec.match.lon.toFixed(3)}`);
        markersLayer.addLayer(marker);
      });
      if(last25.length) map.fitBounds(markersLayer.getBounds().pad(0.5));
    }

    updateGrid(' '.repeat(ACTIVE_DIGITS));

        function convertToMag(incoord, DlatDeg, DlongDeg) {
            const R = 1.0;           // radius (arbitrary unit)

            const deg2rad = Math.PI / 180;
            const rad2deg = 180 / Math.PI;

            // convert pole positions to radians
            const Dlong = DlongDeg * deg2rad;
            const Dlat = DlatDeg * deg2rad;

            // helper: ensure input is an array of pairs
            let single = false;
            let coords;
            if (!Array.isArray(incoord)) {
                throw new TypeError("incoord must be [lat, lon] or array of [lat, lon] pairs");
            }
            // detect single pair vs array of pairs
            if (typeof incoord[0] === "number") {
                // single pair like [lat, lon]
                single = true;
                coords = [incoord];
            } else {
                // assume array of pairs
                coords = incoord;
            }

            // Rotation matrix for longitude: rotate around z by +Dlong
            // geolong2maglong = [ [cos(Dlong), sin(Dlong), 0],
            //                     [-sin(Dlong), cos(Dlong), 0],
            //                     [0, 0, 1] ]
            const geolong2maglong = [
                [Math.cos(Dlong), Math.sin(Dlong), 0],
                [-Math.sin(Dlong), Math.cos(Dlong), 0],
                [0, 0, 1]
            ];

            // Rotation matrix for latitude: rotate by (pi/2 - Dlat) in the meridian plane
            // tomaglat[0,0] = cos(pi/2 - Dlat) = sin(Dlat)
            // tomaglat[0,2] = -sin(pi/2 - Dlat) = -cos(Dlat)
            // tomaglat[2,0] = sin(pi/2 - Dlat) = cos(Dlat)
            // tomaglat[2,2] = cos(pi/2 - Dlat) = sin(Dlat)
            // tomaglat[1,1] = 1
            const a = Math.cos(Math.PI / 2 - Dlat); // = sin(Dlat)
            const b = Math.sin(Math.PI / 2 - Dlat); // = cos(Dlat)
            // I'll keep the same symbols as IDL for clarity:
            const tomaglat = [
                [a, 0, -b],
                [0, 1, 0],
                [b, 0, a]
            ];

            // matrix-vector multiply helper (3x3 * 3x1)
            function matMulVec(mat, vec) {
                return [
                mat[0][0] * vec[0] + mat[0][1] * vec[1] + mat[0][2] * vec[2],
                mat[1][0] * vec[0] + mat[1][1] * vec[1] + mat[1][2] * vec[2],
                mat[2][0] * vec[0] + mat[2][1] * vec[1] + mat[2][2] * vec[2]
                ];
            }

            // For each input coordinate do conversion
            const out = coords.map(pair => {
                const latDeg = pair[0];
                const lonDeg = pair[1];

                // geographic to radians
                const glat = latDeg * deg2rad;
                const glon = lonDeg * deg2rad;
                const galt = R;

                // rectangular coordinates (geographic)
                // x = r * cos(lat) * cos(lon)
                // y = r * cos(lat) * sin(lon)
                // z = r * sin(lat)
                const x = galt * Math.cos(glat) * Math.cos(glon);
                const y = galt * Math.cos(glat) * Math.sin(glon);
                const z = galt * Math.sin(glat);

                // first rotation: longitude rotation (geolong2maglong)
                const v1 = matMulVec(geolong2maglong, [x, y, z]);

                // second rotation: tilt into magnetic dipole (tomaglat)
                const v2 = matMulVec(tomaglat, v1);

                // convert back to latitude, longitude (degrees)
                // mlat = atan(z, sqrt(x^2 + y^2))
                const mlatRad = Math.atan2(v2[2], Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]));
                const mlonRad = Math.atan2(v2[1], v2[0]);

                let mlatDeg = mlatRad * rad2deg;
                let mlonDeg = mlonRad * rad2deg;

                // Normalize longitude to [-180, 180)
                if (mlonDeg >= 180) mlonDeg -= 360;
                if (mlonDeg < -180) mlonDeg += 360;

                return [mlatDeg, mlonDeg];
            });

            return single ? out[0] : out;
        }

        function convertFromMag(incoord, DlatDeg, DlongDeg) {
            const R = 1.0;           // radius (arbitrary unit)

            const deg2rad = Math.PI / 180;
            const rad2deg = 180 / Math.PI;

            // convert pole positions to radians
            const Dlong = DlongDeg * deg2rad;
            const Dlat = DlatDeg * deg2rad;

            // helper: ensure input is an array of pairs
            let single = false;
            let coords;
            if (!Array.isArray(incoord)) {
                throw new TypeError("incoord must be [lat, lon] or array of [lat, lon] pairs");
            }
            // detect single pair vs array of pairs
            if (typeof incoord[0] === "number") {
                // single pair like [lat, lon]
                single = true;
                coords = [incoord];
            } else {
                // assume array of pairs
                coords = incoord;
            }

            // INVERSE rotation matrix for longitude: transpose of original
            // Original was rotate around z by +Dlong, inverse is rotate by -Dlong
            const maglong2geolong = [
                [Math.cos(Dlong), -Math.sin(Dlong), 0],
                [Math.sin(Dlong), Math.cos(Dlong), 0],
                [0, 0, 1]
            ];

            // INVERSE rotation matrix for latitude: transpose of original
            // Original tomaglat rotated by (pi/2 - Dlat), inverse rotates back
            const a = Math.cos(Math.PI / 2 - Dlat); // = sin(Dlat)
            const b = Math.sin(Math.PI / 2 - Dlat); // = cos(Dlat)
            const frommaglat = [
                [a, 0, b],
                [0, 1, 0],
                [-b, 0, a]
            ];

            // matrix-vector multiply helper (3x3 * 3x1)
            function matMulVec(mat, vec) {
                return [
                mat[0][0] * vec[0] + mat[0][1] * vec[1] + mat[0][2] * vec[2],
                mat[1][0] * vec[0] + mat[1][1] * vec[1] + mat[1][2] * vec[2],
                mat[2][0] * vec[0] + mat[2][1] * vec[1] + mat[2][2] * vec[2]
                ];
            }

            // For each input coordinate do conversion
            const out = coords.map(pair => {
                const mlatDeg = pair[0];  // magnetic latitude
                const mlonDeg = pair[1];  // magnetic longitude

                // magnetic coordinates to radians
                const mlat = mlatDeg * deg2rad;
                const mlon = mlonDeg * deg2rad;
                const malt = R;

                // rectangular coordinates (magnetic)
                // x = r * cos(lat) * cos(lon)
                // y = r * cos(lat) * sin(lon)
                // z = r * sin(lat)
                const x = malt * Math.cos(mlat) * Math.cos(mlon);
                const y = malt * Math.cos(mlat) * Math.sin(mlon);
                const z = malt * Math.sin(mlat);

                // first INVERSE rotation: undo magnetic dipole tilt (frommaglat)
                const v1 = matMulVec(frommaglat, [x, y, z]);

                // second INVERSE rotation: undo longitude rotation (maglong2geolong)
                const v2 = matMulVec(maglong2geolong, v1);

                // convert back to latitude, longitude (degrees)
                // glat = atan(z, sqrt(x^2 + y^2))
                const glatRad = Math.atan2(v2[2], Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]));
                const glonRad = Math.atan2(v2[1], v2[0]);

                let glatDeg = glatRad * rad2deg;
                let glonDeg = glonRad * rad2deg;

                // Normalize longitude to [-180, 180)
                if (glonDeg >= 180) glonDeg -= 360;
                if (glonDeg < -180) glonDeg += 360;

                return [glatDeg, glonDeg];
            });

            return single ? out[0] : out;
        }        

  </script>
</body>
</html>
